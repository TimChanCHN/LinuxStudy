<!--
 * @Description: In User Settings Edit
 * @Author: your name
 * @Date: 2019-09-15 22:58:56
 * @LastEditTime: 2019-10-22 09:51:14
 * @LastEditors: Please set LastEditors
 -->
# 进程
## 1 概述
1. 进程是程序的动态执行过程--【程序是静态存储在磁盘中】
2. 系统会为每个进程分配4G的虚拟地址空间，其中0-3G是用户空间，3G-4G是内核空间
   > 进程由内核空间、堆栈、静态数据区、代码段等组成
   ![进程的组成](https://github.com/TimChanCHN/pictures/raw/master/Linux/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png)
3. 进程分类： 交互式进程、批量式进程、守护进程
4. 进程状态：执行态、就绪态、执行态
5. 进程号(pid)： 表示当前进程的ID(ps -ef/ ps -aux可以查看当前进程信息)

## 2 进程的操作
1. 创建进程
   1. fork函数
    > 在fork产生的子进程中，其pid等于0  
    > 在父进程中，fork返回的pid是子进程的pid  
2. 获得进程号
   getpid()

3. 孤儿进程
   当父进程先于子进程结束，子进程成为孤儿进程，子进程会被1号进程接管

4. 僵尸进程
   子进程先于父进程结束，子进程资源没有被回收，被称之为僵尸进程。  
   僵尸进程会造成内存资源被占用，因此需要对资源进程回收

5. 回收僵尸进程函数--wait/waitpid
   1. wait --> 当前进程会阻塞等待子进程的结束，之后会回收它的资源
   2. watipid --> 同样功能，但是可以设置回收多个子进程的资源，可以阻塞以及非阻塞等待资源回收  
    ![waitpid参数设置](https://github.com/TimChanCHN/pictures/raw/master/Linux/waitpid.png)

6. exec函数族
   > 该函数族的作用是取代原进程的数据段、代码段、堆栈段，从而执行该函数执行的命令。若进程中想执行bin目录下面的命令，可以利用该函数。进程结束后，仍需要父进程回收资源
   1. int execlp(const char *file, const char *arg, ...);
   2. int execl(const char *path, const char *arg, ...);
   ...

7. system函数
   > 功能等同于exec函数族，但是它是在原有进程的基础上再创建一个进程，system进程结束后，会自己回收进程资源。

## 3 进程间通信
1. 无名管道
   1. 特点：
     > 用户层不可见  
     > 只能再有亲缘关系的进程中通信  
     > 无名管道有读端和写端，pipefd[0]是读端，pipefd[1]是写端  
     > 当读端关闭，而对管道进行写的时候，会造成管道破裂  
    2. 无名管道创建  
     > int pipe(int pipefd[2])

    3. 虽然单个管道是单向通信，但是可以再两个进程中可以设置多个管道，则可以实现双向通信，也可以对管道两端进行分时复用实现双向通信
   
2. 命名管道
   1. 特点
     > 用户层可见  
     > 在用户层会对有名管道创建一个管道文件，进程通过节点访问有名管道
     > 父子进程、陌生进程均可以通信
     > 如果open只打开管道的读端/写端，就会在open处发生阻塞  
    2. 相关函数
    > mkfifo--> 创建管道文件  
    > unlink --> 删除管道文件 

3. 共享内存
   1. 特点
    > 在进程空间中直接映射一段空间到共享内存中，由于所有进程公用内核空间，因此其他内存也能直接在该内存中进行操作  
    > 所有通信机制中效率最高的一种（因为它直接操作内存，不需要对数据进行拷贝）  
    2. 相关操作
    > shmget --> 创建或打开共享内存  
    > shmat --> 映射共享内存  
    > shmdt --> 撤销共享内存  
    > shmctl --> 删除共享内存（该函数还有其他功能）

4. 消息队列
   1. 特点
    > 和队列特点一致，都是FIFO  
    > 可以先往消息队列中先存储信息，需要用的时候再打开读取信息  
   2. 相关操作
    > msgget--> 创建/打开消息队列
    > msgsnd --> 添加消息包到队尾，并发送消息
    > msgrcv --> 接收消息  
    > msgctl --> 删除消息队列（该函数还有其他功能）

5. 信号量
   1. 特点
    > 每个信号量都有非负整数值  
    > 信号量是用于提供不同进程间/同一进程的不同线程的同步手段  
    > P操作-->减1操作    V操作-->加1操作  
    2. 相关操作
    > semget --> 创建/打开信号量集  
    > semop --> 操作信号量集
    > semctl --> 信号集命令函数

6. 信号
   1. 特点
    > 就是一种软中断，等待某个信号的发生，从而触发相关的中断服务程序  
    > 是一种异步机制  
   2. 进程队信号的处理方式
    > SIG_DEL   -->     默认动作（暂停线程）  
    > SIG_IGN   -->     忽略信号  
    > 执行用户希望的动作-->中断服务程序

   3. 相关操作函数  
    1. signal(signum,handler);
        > 只要signum事件发生，程序转去执行handler程序  
        > 若signum不发生，则执行原来进程内容  
    2. kill 
        > 发送信号
    3. raise
        > 信号发送
    4. pause/alarm
        > 当alarm的事件发生时，pause挂起当前进程

## 4 内存映射 mmap
1. 区别
   1. 进程间通信的共享内存本质就是一种内存映射，但是它映射的是内核空间，本质还是虚拟地址；
   2. mmap是映射磁盘，但它不是进程间通信的一种方式
2. 相关操作函数
   1. mmap --> 实现内存映射
   2. munmap --> 取消内存映射
